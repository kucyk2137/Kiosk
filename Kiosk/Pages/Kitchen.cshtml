@page
@model Kiosk.Pages.KitchenModel
<link rel="stylesheet" href="~/css/Kitchen.css" />
@{
    ViewData["Title"] = Localizer["Kuchnia"];
    ViewData["HidePageHeader"] = true;
}

<div class="kitchen-screen">
    <div class="kitchen-topbar">
        <div>
            <p class="eyebrow">@Localizer["Panel kuchni"]</p>
            <h1>@Localizer["Oczekujące zamówienia"]</h1>
            <p class="muted">@Localizer["Nowe zamówienia pojawiają się automatycznie – kliknij Gotowe gdy wydasz potrawy."]</p>
        </div>
        <div class="kitchen-actions">
            <div id="order-count" class="pill">@Localizer["0 w kolejce"]</div>
            <button id="refresh-orders" type="button" class="ghost-btn">@Localizer["Odśwież"]</button>
        </div>
    </div>

    <div id="orders-grid" class="kitchen-grid">
        <div class="empty-state">
            <p class="eyebrow">@Localizer["Brak zamówień"]</p>
            <h3>@Localizer["Wszystkie zamówienia zostały zrealizowane"]</h3>
            <p class="muted">@Localizer["Nowe zamówienia pokażą się tutaj natychmiast po złożeniu."]</p>
        </div>
    </div>

    <a class="history-fab" href="/KitchenHistory">@Localizer["Historia zamówień"]</a>
</div>

<script>
    const i18n = {
        emptyTitle: '@Localizer["Brak zamówień"]',
        emptySubtitle: '@Localizer["Wszystkie zamówienia zostały zrealizowane"]',
        emptyHint: '@Localizer["Nowe zamówienia pokażą się tutaj natychmiast po złożeniu."]',
        queueSuffix: '@Localizer["w kolejce"]',
        orderLabel: '@Localizer["Zamówienie"]',
        defaultOrderType: '@Localizer["Na miejscu"]',
        ready: '@Localizer["Gotowe"]',
        pickedUp: '@Localizer["Odebrane"]',
        markReadyError: '@Localizer["Nie udało się oznaczyć zamówienia jako gotowe."]',
        closeError: '@Localizer["Nie udało się zamknąć zamówienia."]',
        closeGenericError: '@Localizer["Wystąpił błąd podczas zamykania zamówienia."]',
        fetchError: '@Localizer["Nie udało się pobrać zamówień."]',
        none: '@Localizer["Brak"]',
        without: '@Localizer["bez -"]',
        baseIngredients: '@Localizer["Składniki podstawowe"]',
        extraIngredients: '@Localizer["Dodatki"]'
    };
    const orderTypeLabels = {
        "Na miejscu": i18n.defaultOrderType,
        "Na wynos": '@Localizer["Na wynos"]'
    };
    const paymentMethodLabels = {
        "Karta": '@Localizer["Karta"]',
        "Gotówka": '@Localizer["Gotówka"]',
        "BLIK": "BLIK"
    };

    const ordersGrid = document.getElementById('orders-grid');
    const orderCount = document.getElementById('order-count');
    const refreshButton = document.getElementById('refresh-orders');

    const formatTime = (dateString) => {
        const date = new Date(dateString);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    };
    const parseIngredients = (ingredients) => {
        try {
            const parsed = JSON.parse(ingredients || '[]');
            return Array.isArray(parsed) ? parsed : [];
        } catch {
            return [];
        }
    };

    const countOccurrences = (ingredients) => ingredients.reduce((acc, name) => {
        acc[name] = (acc[name] || 0) + 1;
        return acc;
    }, {});

    const buildIngredientsMarkup = (item) => {
        const selectedList = parseIngredients(item.ingredients);
        const selectedCounts = countOccurrences(selectedList);
        const quantity = item.quantity || 1;
        Object.keys(selectedCounts).forEach(name => {
            selectedCounts[name] *= quantity;
        });
        const defaultIngredients = item.defaultIngredients || [];
        const optionalIngredients = item.optionalIngredients || [];

        const formatWithCount = (name) => {
            const count = selectedCounts[name] || 0;
            return count > 1 ? `${count}x ${name}` : name;
        };

        const selectedDefaults = defaultIngredients
            .filter(name => selectedCounts[name])
            .map(formatWithCount);
        const removedDefaults = defaultIngredients.filter(name => !selectedCounts[name]);
        const selectedOptionals = optionalIngredients
            .filter(name => selectedCounts[name])
            .map(formatWithCount);

        const toEntries = (list, className = '') => list.map(text => ({ text, className }));
        const renderEntries = (entries) => entries.length
            ? entries.map(({ text, className }) => `<li${className ? ` class=\"${className}\"` : ''}>${text}</li>`).join('')
            : `<li class="muted">${i18n.none}</li>`;

        const defaultEntries = [
            ...toEntries(selectedDefaults),
            ...toEntries(removedDefaults.map(name => `${i18n.without} ${name}`), 'removed-ingredient')
        ];
        const optionalEntries = toEntries(selectedOptionals);

        if (!defaultEntries.length && !optionalEntries.length) {
            return '';
        }

        return `
                    <div class="item-ingredients">
                        <div class="ingredient-group">
                            <div class="ingredient-label">${i18n.baseIngredients}</div>
                            <ul class="ingredient-list">
                                ${renderEntries(defaultEntries)}
                            </ul>
                        </div>
                        <div class="ingredient-group">
                            <div class="ingredient-label">${i18n.extraIngredients}</div>
                            <ul class="ingredient-list">
                                ${renderEntries(optionalEntries)}
                            </ul>
                        </div>
                    </div>`;
    };
    const renderOrders = (orders) => {
        ordersGrid.innerHTML = '';

        if (!orders.length) {
            ordersGrid.innerHTML = `
                        <div class="empty-state">
                            <p class="eyebrow">@Localizer["Brak zamówień"]</p>
                            <h3>@Localizer["Wszystkie zamówienia zostały zrealizowane"]</h3>
                            <p class="muted">@Localizer["Nowe zamówienia pokażą się tutaj natychmiast po złożeniu."]</p>
                        </div>`;
        }

        orderCount.textContent = `${orders.length} ${i18n.queueSuffix}`;

        orders.forEach(order => {
            const card = document.createElement('article');
            card.className = 'kitchen-card';
            if (order.isReady) {
                card.classList.add('is-ready');
            }
            card.dataset.isReady = order.isReady;
            card.innerHTML = `
                        <header class="card-head">
                            <div>
                                <div class="eyebrow">${i18n.orderLabel} ${order.orderNumber || `#${order.orderId}`}</div>
                                <div class="order-time">${orderTypeLabels[order.orderType] || order.orderType || i18n.defaultOrderType} • ${formatTime(order.orderDate)}</div>
                            </div>
                            <div class="badge-row">
                                <span class="pill pill--accent">${paymentMethodLabels[order.paymentMethod] || order.paymentMethod}</span>
                                    ${order.isReady ? `<span class="pill pill--success">${i18n.ready}</span>` : ''}
                            </div>
                        </header>
                        <div class="card-body">
                            ${order.items.map(item => `
                                <div class="order-item">
                                    <span class="qty">${item.quantity}x</span>
                                    <div class="item-details">
                                        <div class="item-name">${item.dishName}</div>
                                        ${buildIngredientsMarkup(item)}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <footer class="card-actions">
                                <button class="done-btn" data-order-id="${order.orderId}">${order.isReady ? i18n.pickedUp : i18n.ready}</button>
                        </footer>`;

            card.querySelector('.done-btn').addEventListener('click', () => markDone(order.orderId, card));
            ordersGrid.appendChild(card);
        });
    };

    const markDone = async (orderId, card) => {
        card.classList.add('is-processing');
        const isReady = card.dataset.isReady === 'true';
        const endpoint = isReady ? 'complete' : 'ready';
        try {
            const response = await fetch(`/api/orders/${orderId}/${endpoint}`, { method: 'POST' });
            if (!response.ok) {
                const payload = await response.json().catch(() => ({}));
                const defaultMessage = isReady
                    ? i18n.closeError
                    : i18n.markReadyError;
                alert(payload.message || defaultMessage);
            }
            if (!isReady) {
                card.dataset.isReady = 'true';
                card.classList.add('is-ready');
                card.querySelector('.done-btn').textContent = i18n.pickedUp;
                card.querySelector('.badge-row')
                    .insertAdjacentHTML('beforeend', `<span class="pill pill--success">${i18n.ready}</span>`);
            }
            await loadOrders();
        } catch (err) {
            alert(i18n.closeGenericError);
        } finally {
            card.classList.remove('is-processing');
        }
    };

    const loadOrders = async () => {
        ordersGrid.classList.add('is-loading');
        try {
            const response = await fetch('/api/orders');
            const data = await response.json();
            renderOrders(data);
        } catch (err) {
            ordersGrid.innerHTML = `<p class="muted">${i18n.fetchError}</p>`;
        } finally {
            ordersGrid.classList.remove('is-loading');
        }
    };

    refreshButton.addEventListener('click', loadOrders);
    loadOrders();
    setInterval(loadOrders, 10000);
</script>